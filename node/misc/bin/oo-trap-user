#!/usr/bin/python -tt

import ast
import sys, os
import pwd
import syslog
import glob
import base64
import commands
import re
import selinux
import subprocess
import itertools
import shlex

# Shell compatible split that honors quoted strings
shsplit = lambda a: [b.decode('utf-8') for b in shlex.split(a.encode('utf-8'))]

EXT_LIB = "/usr/libexec/openshift/lib/util"

commands_map = {
    "git-receive-pack": "/usr/bin/git-receive-pack",
    "git-upload-pack": "/usr/bin/git-upload-pack",
    "snapshot": "/bin/bash",
    "restore": "/bin/bash",
    "binary-deploy": "/bin/bash",
    "tail": "/usr/bin/tail",
    "rhcsh": "/bin/bash",
    "true": "/bin/true",
    "java": "/bin/bash",
    "scp": "/bin/bash",
    "cd": "/bin/bash",
    "set": "/bin/bash",
    "mkdir": "/bin/bash",
    "test": "/bin/bash",
    "rsync": "/bin/bash",
    "ctl_all": "/bin/bash",
    "deploy.sh": "/bin/bash",
    "rhc-list-ports": "/bin/bash",
    "post_deploy.sh": "/bin/bash",
    "quota": "/usr/bin/quota"
}

comment_re = re.compile("#.*$")

# These should come from somewhere, not be hard coded - MAL
openshift_cgroup_subsystems="cpu,cpuacct,memory,net_cls,freezer"

def load_env(directory):
    for entry in glob.glob(os.path.expanduser(os.path.join(directory, '*'))):
        env = os.path.basename(entry)
        if os.path.isdir(entry):
            load_env(os.path.join(directory, entry))
            continue

        if entry.endswith(".rpmnew"):
            continue

        with open(entry, 'r') as file:
            contents = file.read().rstrip()
            # unicodedata.normalize doesn't remove null's which are illegal in environment variables re: python
            os.environ[env] = ''.join(contents.split('\0'))


def gear_env():
    load_env('/etc/openshift/env')
    system_path = os.environ['PATH']

    load_env('~/.env')
    load_env('~/*/env/')

    primary = ''
    if 'OPENSHIFT_PRIMARY_CARTRIDGE_DIR' in os.environ:
        primary = os.path.basename(os.environ['OPENSHIFT_PRIMARY_CARTRIDGE_DIR'].rstrip('/')).upper()
        load_env(os.path.join(os.environ['OPENSHIFT_PRIMARY_CARTRIDGE_DIR'], 'env'))

    os.environ['PATH'] = ':'.join(collect_elements_from(os.environ, 'PATH', primary))
    os.environ['LD_LIBRARY_PATH'] = ':'.join(collect_elements_from(os.environ, 'LD_LIBRARY_PATH', primary))

    load_env('~/.env/user_vars')

def collect_elements_from(env, var_name, primary):
    primary_path = "OPENSHIFT_%s_%s_ELEMENT" % (primary, var_name)
    gear_env = dict(env)
    system_path = gear_env[var_name] if var_name in gear_env else False

    # Remove all LD_LIBRARY_PATH_ELEMENT's to avoid conflict with
    # PATH
    #
    if var_name == 'PATH':
        regex = re.compile(r'_LD_LIBRARY_PATH_ELEMENT$')
        for k in gear_env.keys():
            if regex.search(k):
                gear_env.pop(k)

    elements = []
    for name in gear_env.keys():
        regex = re.compile(r'OPENSHIFT_.*_%s_ELEMENT' % var_name)
        if regex.search(name) and primary_path != name:
            elements.append(gear_env[name])

    if primary_path in gear_env:
        if var_name == 'PATH':
            elements.insert(0, gear_env[primary_path])
        else:
            elements.append(gear_env[primary_path])

    if system_path:
        elements.append(system_path)

    return elements



# Calling oo-get-mcs-level gets into trouble due to BZ 957257.  Use an
# internal call which produces the same logic.
def get_mcs_level(uid):
    set_size = 1024
    group_size = 2
    uid_offset = 0
    mls_num = 0

    mcs_set = [ "c%d" % n for n in xrange(set_size) ]
    iuid = uid_offset

    for mcs_col in itertools.combinations(mcs_set, 2):
        iuid+=1
        if iuid == uid:
            return "s%d:%s" % ( mls_num, ",".join(mcs_col) )


def read_config():
  config = {}
  f = open('/etc/openshift/node.conf','r')
  data = f.read()
  f.close()
  lines = data.split("\n")
  for line in lines:
    clean_line = comment_re.sub("", line) # remove comments
    clean_line = clean_line.strip() # remove leading and trailing white space
    if clean_line != "":
      split_line = clean_line.split("=")
      if len(split_line) != 2:
          syslog.syslog("node config error: %s" % (line))
          sys.stderr.write("Error in node configuration")
          sys.exit(2)  # need to set the proper exit code
      value = split_line[1].strip('\'"') # remove quotes from value strings
      config[split_line[0]] = value
  return config

#  There are two possible command sources:
#
#  1) authenticate with SSH public key, and key has command= section
#     Get command and args from SSH_ORIGINAL_COMMAND
#  2) Authenticate with other means (Kerberos or ...)
#     Get command and args from sys.argv
#
# Three possible command conditions exist
#
#  1) user did not specify a remote command to execute
#     use rhcsh
#  2) user specified a command which is in commands_map
#     adjust the arguments and environment and execute the command
#  3) user specified a command which is not in commands_map
#     pass to bash with -c
#
if __name__ == '__main__':

    # Customize logging information
    syslog.openlog('oo-trap-user')

    config = read_config()
    gear_env()

    # Determine the command source
    # Start with the command passed by the user through SSH
    allargs = shell_args = sys.argv
    # allargs are for the arguments split on whitespace (easy to reconstruct)
    # shell_args are for the arguments as the shell would understand them
    #
    # be careful not to recurse (ssh adds $SHELL -c)
    if allargs[:2] == ['/usr/bin/oo-trap-user', '-c']:
        # the final command is a SINGLE string
        #syslog.syslog(syslog.LOG_DEBUG, "shell_args: " + str(shell_args))
        allargs = shell_args[2].split()
        shell_args = shsplit(shell_args[2])
        # Provide for authorized_keys entries of form "NAME=value /usr/bin/oo-trap-user"
        while shell_args[0].find("=") > 0:
             nv = shell_args.pop(0) #remove NAME=VALUE from beginning of command
             nv = nv.split("=",2)
             os.environ[nv[0]] = nv[1]

    # has sys.argv been replaced by an ssh key command?
    orig_cmd = os.environ.get('SSH_ORIGINAL_COMMAND')
    if orig_cmd != None:
        # extract the command which was replaced by SSH auth key command
        #syslog.syslog(syslog.LOG_DEBUG, "orig_cmd: " + orig_cmd)
        allargs = shell_args = orig_cmd.split() if orig_cmd else []

    if shell_args == ['/usr/bin/oo-trap-user'] or shell_args == []:
        # no command, avoid recursion, drop to shell
        #syslog.syslog(syslog.LOG_DEBUG, "no command: drop to rhcsh")
        allargs = shell_args = ['rhcsh']

    # Log OpenShift login if known, plus gear UUID
    if config.get('SYSLOG_GEAR_LOGIN') == 'true':
        syslog.syslog("oo_login: %s from: %s gearUuid=%s cmd=%s" %
                     (os.environ.get('OPENSHIFT_LOGIN'), os.environ.get('SSH_CLIENT').split()[0],
                     os.environ.get('OPENSHIFT_GEAR_UUID'), ' '.join(allargs)))

    # Determine the command to execute: use from command_map if provided
    try:
        # Check the commmand_map for special "trapped" commands
        #syslog.syslog(syslog.LOG_DEBUG,
        #              "trying trapped commands from: " + str(allargs))
        basecmd = os.path.basename(shell_args[0])
        #syslog.syslog(syslog.LOG_DEBUG, "basecmd = " + basecmd)
        cmd = commands_map[basecmd]
        #syslog.syslog(syslog.LOG_DEBUG, "cmd = " + cmd)
    except:
        # Catch all, just run the command as is via bash.
        #syslog.syslog(syslog.LOG_DEBUG,
        #              "executing command with bash: " + ' '.join(allargs))
        cmd = "/bin/bash"
        str = ' '.join(allargs)
        allargs = ['-c', str]
    if basecmd in ('snapshot',):
        # This gets called with "snapshot"
        allargs = ['oo-snapshot']
    if basecmd in ('restore',):
        # This gets called with "restore <INCLUDE_GIT>"
        include_git = False
        if len(allargs) > 1 and allargs[1] == 'INCLUDE_GIT':
            include_git = True

        allargs = ['oo-restore']
        if include_git:
            allargs.append('INCLUDE_GIT')
    if basecmd in ('binary-deploy',):
        allargs = ['oo-binary-deploy']
    elif basecmd in ('rhcsh',):
        os.environ["PS1"] = "rhcsh> "
        if len(allargs) < 2:
            allargs = ['--init-file', '/usr/bin/rhcsh', '-i']
        else:
            str = ' '.join(allargs[1:])
            allargs = ['--init-file', '/usr/bin/rhcsh', '-c', str]
    elif basecmd in ('ctl_all',):
        allargs = ['-c', '. /usr/bin/rhcsh > /dev/null ; ctl_all %s' % allargs[-1]]
    elif basecmd in ('java','set','scp', 'cd', 'test', 'mkdir', 'rsync', 'deploy.sh', 'post_deploy.sh', 'rhc-list-ports'):
        str = ' '.join(allargs)
        allargs = ['-c', str]
    elif basecmd in ('tail',):
        files = []

        files_start_index = 1
        args = []
        add_follow = True
        if allargs[1] == '--opts':
            files_start_index = 3
            args_str = base64.standard_b64decode(allargs[2])
            args = args_str.split()
            for arg in args:
                if arg.startswith(('..', '/')):
                    print "All paths must be relative: " + arg
                    sys.exit(88)
                elif arg == '-f' or arg == '-F' or arg.startswith('--follow'):
                    add_follow = False

        for glob_list in allargs[files_start_index:]:
            for f in glob.glob(glob_list):
                try:
                    if os.path.islink(f) and os.path.lexists(f):
                        files.append(f)
                    else:
                        files.append(f)
                except OSError, e:
                    print "Error: %s" % e.strerror
                    sys.exit(91)
        if len(files) == 0:
            print "Could not find any files matching glob"
            sys.exit(32)
        allargs = []
        allargs.extend(args)
        if add_follow:
            allargs.append('-f')
        allargs.extend(files)
    elif basecmd in ('git-receive-pack', 'git-upload-pack'):
        # git repositories need to be parsed specially
        thearg = ' '.join(allargs[1:])
        if thearg[0] == "'" and thearg[-1] == "'":
            thearg = thearg.replace("'","")
        thearg = thearg.replace("\\'", "")
        thearg = thearg.replace("//", "/")

        # replace leading tilde (~) with user's home path
        realpath = os.path.expanduser(thearg)
        if not realpath.startswith(config['GEAR_BASE_DIR']):
            syslog.syslog("Invalid repository: not in openshift_root (%s) - %s: (%s)" %
                          (config['GEAR_BASE_DIR'], thearg, realpath))
            print "Invalid repository %s: not in application root" % thearg
            sys.exit(3)

        if not os.path.isdir(realpath):
            syslog.syslog("Invalid repository %s (%s)" % (thearg, realpath))
            print "Invalid repository %s: not a directory" % thearg
            sys.exit(3)
        allargs = [thearg]

    elif basecmd in ('quota',):
        allargs = ['--always-resolve']

    # Set umask same as the ssh session - BZ990441
    try:
      umask = ast.literal_eval(os.environ['OPENSHIFT_UMASK'])
    except (ValueError, SyntaxError, KeyError) as e:
      umask = 077

    os.umask(umask)

    runcon = '/usr/bin/runcon'
    mcs_level = get_mcs_level(os.getuid())

    target_context = 'unconfined_u:system_r:openshift_t:%s' % mcs_level
    actual_context = selinux.getcon()[1]
    if target_context != actual_context:
        print "Invalid context: %s, expected %s\n" % (actual_context, target_context)
        sys.exit(40)
        # This else is left in because at the time of writing this statement
        # We have a patched ssh running.  Remove the exit above and it should
        # work on other platforms.
        os.execv(runcon, [runcon, target_context, cmd] + allargs)
        sys.exit(1)
    else:
        os.execv(cmd, [cmd] + allargs)
        sys.exit(1)
