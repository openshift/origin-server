#!/bin/bash -e

set -x
export | grep 'POSTGRES\|PG'

source $OPENSHIFT_CARTRIDGE_SDK_BASH

function _is_running {
  # Can't use pg_ctl status here because it doesn't mean the db is done starting up
  psql -l -h $OPENSHIFT_POSTGRESQL_DB_SOCKET_DIR -U postgres 2>&1 > /dev/null
  return $?
}

function wait_for_postgres_availability {
  for i in {1..30}; do
    _is_running && return 0
    sleep 1
  done
}

function start {
  if ! _is_running; then
    echo "Starting Postgres"
    # Should be able to use '-w -t 30' here but it always fails
    pg_ctl start -D $OPENSHIFT_POSTGRESQL_DB_PGDATA
    wait_for_postgres_availability

    if _is_running; then
      echo "Postgres started"
    else
      error "Could not start Postgres" 70
    fi
  else
    echo "Postgres already running"
  fi
  return 0
}

function stop {
  if _is_running; then
    pg_ctl stop -D $OPENSHIFT_POSTGRESQL_DB_PGDATA -m smart -w -t 30 ||
      pg_ctl stop -D $OPENSHIFT_POSTGRESQL_DB_PGDATA -m fast -w -t 30 ||
      pg_ctl stop -D $OPENSHIFT_POSTGRESQL_DB_PGDATA -m immediate -w -t 30 ||
      pkill postgres
    if _is_running; then
      error "Could not stop Postgres" 70
    else
      truncate -s0 $OPENSHIFT_POSTGRESQL_DB_PID
      echo "Postgres stopped"
    fi
  else
    echo "Postgres already stopped"
  fi
  return 0
}

function status {
  if _is_running; then
    client_result "Postgres is running"
  else
    client_result "Postgres is stopped"
  fi

  exit 0
}

function pre_snapshot {
  start

  local dump_file="${OPENSHIFT_DATA_DIR}/postgresql_dump_snapshot.gz"
  local dump_user="${OPENSHIFT_DATA_DIR}/postgresql_db_username"

  echo "$OPENSHIFT_POSTGRESQL_DB_USERNAME" > $dump_user

  pg_dumpall -h $OPENSHIFT_POSTGRESQL_DB_SOCKET_DIR -c -U postgres | gzip -9 > $dump_file

  if [ ! ${PIPESTATUS[0]} -eq 0 ]
  then
    warning "WARNING!  Could not dump Postgres databases!  Continuing anyway"
    rm -f $dump_file
  fi

  stop
}

function post_snapshot {
  true
}

function pre_restore {
  true
}

function post_restore {
  local dump_file="${OPENSHIFT_DATA_DIR}/postgresql_dump_snapshot.gz"
  local dump_user="${OPENSHIFT_DATA_DIR}/postgresql_db_username"

  # TODO: Ensure the credentials are properly flushed
  # TODO: Ensure the uids are correct in the pg_* files
  if [ -f $dump_file ]
  then
    start
    local new_user=$OPENSHIFT_POSTGRESQL_DB_USERNAME
    # Restore the dumped file
    zcat $dump_file | psql -U postgres -h $OPENSHIFT_POSTGRESQL_DB_SOCKET_DIR -d postgres
    # Change the username and password if the username changed
    if [ "$new_user" != "$dump_user" ]
    then
      {
        echo "
        ALTER USER ${dump_user} RENAME TO ${new_user};
        ALTER USER ${new_user} PASSWORD '${pass}';
        " | psql -d $db -h $socket -U postgres
      } || warning "Could not change credentials"
    fi

    if [ ! ${PIPESTATUS[1]} -eq 0 ]
    then
      warning "Error: Could not import Postgres Database!  Continuing..."
    fi
    cleanup_dump
  else
    warning "Postgres restore attempted, but no dump found"
    warning "${dump_file} does not exist"
  fi
}

function cleanup_dump {
  local dump_file="${OPENSHIFT_DATA_DIR}/postgresql_dump_snapshot.gz"
  local dump_user="${OPENSHIFT_DATA_DIR}/postgresql_db_username"

  rm -f $dump_file
  rm -f $dump_user
}

case "$1" in
  start)
    start
  ;;
  stop)
    stop
  ;;
  status)
    status
  ;;
  restart)
    stop
    start
  ;;
  pre-snapshot)
    pre_snapshot
  ;;
  post-snapshot)
    post_snapshot
  ;;
  pre-restore)
    pre_restore
  ;;
  post-restore)
    post_restore
  ;;
esac
