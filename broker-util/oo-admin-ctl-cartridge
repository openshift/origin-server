#!/usr/bin/env oo-ruby

require 'optparse'
require 'ostruct'

PATH = '/var/www/openshift/broker/config/environment'

class Command
  def import_node(options)
    env!(options)
    carts = OpenShift::ApplicationContainerProxy.find_one(options.node).get_available_cartridges
    types = CartridgeType.update_from(carts)
    update_types(options, types)
  end

  def clean(options)
    env!(options)
    puts "Deleting all cartridges from the broker ..."
    CartridgeType.delete_all
    Rails.cache.clear
    0
  rescue => e
    exception e, "Failed to delete some cartridges"
    1
  end

  def list(options)
    env!(options)
    carts = CartridgeType.all
    carts = carts.active unless options.all
    return 0 if carts.empty?

    if options.raw
      carts.each do |type|
        puts JSON.pretty_generate(type.cartridge.to_descriptor)
      end
      return 0
    end

    output = carts.map do |type|
      line = [
        type.priority? ? '*' : ' ',
        type.name,
        case
        when type.is_web_proxy? then "web_proxy"
        when type.is_web_framework? then "web"
        when type.is_plugin? then "plugin"
        else "service"
        end,
        type.display_name,
        type.created_at.strftime("%Y/%m/%d %H:%M:%S %Z"),
        type._id.to_s,
        type.obsolete? ? 'obsolete' : '',
        type.manifest_url,
      ]
      line
    end
    output.sort_by!{ |line| [line[2], line[5].nil? ? 0 : 1, line[1]] }
    output.each{ |line| line.delete_at(5); line.shift } unless options.all

    table(output)
    0
  rescue => e
    warn "Failed to list cartridges"
    warn e.message
    warn e.backtrace
    1
  end

  def delete(options)
    env!(options)
    raise ArgumentError, "--name NAMES is a required argument for delete" if options.names.nil? || options.names.empty?
    carts = CartridgeType.in(name: options.names)
    if carts.empty?
      warn "No cartridges match #{options.names.map{|s| "'#{s}'"}.join(', ')}."
      return 2
    end
    names = carts.map{ |s| "'#{s}'" }.join(', ')
    carts.delete
    puts "#{names} were deleted."
    0
  rescue ArgumentError
    warn $!
    1
  rescue => e
    exception e, "Failed to delete cartridges"
    1
  end

  def deactivate(options)
    env!(options)
    raise ArgumentError, "--id ID is a required argument for deactivate" if options.id.nil?
    cart = CartridgeType.find(options.id)
    if cart.priority
      cart.priority = nil
      cart.save!
      puts "#{cart.name} was deactivated."
    else
      puts "#{cart.name} was not active."
    end
    0
  rescue ArgumentError
    warn $!
    1
  rescue Mongoid::Errors::DocumentNotFound
    warn "The cartridge #{options.id} does not exist."
    2
  rescue => e
    exception e, "Failed to deactivate cartridge"
    1
  end

  def activate(options)
    env!(options)
    raise ArgumentError, "--id ID is a required argument for activate" if options.id.nil?
    cart = CartridgeType.find(options.id)
    if cart.activate
      puts "#{cart._id} is now the active cartridge for #{cart.name}"
      0
    else
      warn "Unable to activate #{options.id}"
      type.errors.full_messages.each do |m|
        warn "  #{m}"
      end
      1
    end
  rescue ArgumentError
    warn $!
    1
  rescue Mongoid::Errors::DocumentNotFound
    warn "The cartridge #{options.id} does not exist."
    2
  rescue => e
    exception e, "Failed to activate cartridge"
    1
  end

  def import(options)
    env!(options)
    raise ArgumentError, "--url URL is a required argument for import" if options.url.nil? || options.url.empty?

    text = CartridgeCache.download_from_url(options.url)
    versions = OpenShift::Runtime::Manifest.manifests_from_yaml(text)
    types = CartridgeType.update_from(versions, options.url)

    if not options.force
      source_change, types = types.partition{ |t| t.manifest_url_changed? && t.persisted? }
      if not source_change.empty?
        warn "Some cartridges had their manifest URLs changed:"
        source_change.each do |c|
          warn "  #{c.name}: #{c.changes['manifest_url'][0]} -> #{c.changes['manifest_url'][1]}"
        end
        warn "You must pass --force to update manifest URLs for imported cartridges"
      end
    end

    update_types(options, types, "from #{options.url}")
  rescue KeyError
    warn text
    raise
  rescue => e
    exception e, "Failed to import cartridge"
    1
  end

  protected
    def env!(options)
      require options.broker || PATH
    end

    def table(output)
      widths = Array.new(output.first.length, 0)
      output.each{ |line| widths.each_with_index{ |w, i| widths[i] = [w, (line[i] || "").length].max } }
      fmt = widths.map{ |w| "%-#{w}s" }.join(" ")
      output.each{ |line| puts fmt % line }
    end

    def update_types(options, types, source=nil)
      if types.empty?
        warn "No changes#{ " #{source}" if source }"
        return 0
      end
      warn "Updating #{types.length} cartridges#{ " #{source}" if source } ..."
      if types.inject(0){ |f, type| f + save_cart(options, type) } > 0
        1
      else
        Rails.cache.clear
        0
      end
    end

    def save_cart(options, type)
      op = type.persisted? || type.has_predecessor? ? "update" : "add"
      if type.send(options.activate ? :activate : :save)
        puts "#{op.capitalize[0]} #{type.name} [#{type._id}]#{ " (obsolete)" if type.obsolete?}"
      else
        warn "Failed to #{op} #{type.name}"
        type.errors.full_messages.each do |m|
          warn "  #{m}"
        end
      end
      0
    rescue => e
      exception e, "Failed to #{op} #{type.name}"
      1
    end

    def warn(*args)
      $stderr.puts(*args)
    end

    def exception(e, *args)
      $stderr.puts(*args)
      $stderr.puts e.message
      $stderr.puts "  #{e.backtrace.join("  \n")}"
    end
end

methods = (Command.instance_methods(false) & Command.new.public_methods).map{ |s| s.to_s.gsub('_', '-')}.sort
options = OpenStruct.new
p = OptionParser.new do |opts|
  opts.banner = "
== Synopsis

#{File.basename $0}: Manage cartridges

Commands:
 activate    - Make a specific cartridge active
 deactivate  - Disable a cartridge from being visible to users
 clean       - Delete all cartridges in the broker
 delete      - Remove one or more named cartridges
 import      - Import a manifest as one or more cartridges
 import-node - Import the latest cartridges from the nodes
 list        - List all cartridges

== Usage: oo-admin-ctl-cartridge -c (#{methods.join('|')})"

  opts.separator ''
  opts.on('-c', '--command COMMAND',
          methods.map(&:to_s),
          [],
          "A command to execute") do |command|
    options.command = command
  end

  opts.on('--broker PATH', "The path to the broker",
          " (default #{PATH})") do |path|
    options.broker = path
  end

  opts.on('--raw', "Dump all cartridge information as JSON") do
    options.raw = true
  end

  opts.on('--force', "Confirm potentially destructive actions") do
    options.force = true
  end

  opts.on('-a', '--all', "Show all cartridges, not just active ones.") do |url|
    options.all = true
  end

  opts.on('--activate', "Mark imported or updated cartridges as active.") do
    options.activate = true
  end

  opts.on('-n NAMES', '--name NAMES', "Comma-delimited cartridge names.") do |names|
    options.names = names.split(/[\, ]/)
  end

  opts.on('--id ID', "Identifier for a cartridge version to activate or deactivate.") do |id|
    options.id = id
  end

  opts.on('--node NODE', "Identifier for a node (server-identity) to import from.") do |node|
    options.node = node
  end

  opts.on('-u URL', '--url URL', "URL of a cartrige manifest to import.") do |url|
    options.url = url
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit 0
  end
end
p.parse!(ARGV)

if options.command.nil?
  puts p
  exit 0
end
exit Command.new.send(options.command.downcase.gsub(/[\-]/,'_'), options)
