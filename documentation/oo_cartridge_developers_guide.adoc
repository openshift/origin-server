= OpenShift Origin Cartridge Specification Guide
OpenShift Origin Documentation Project <dev@lists.openshift.redhat.com>
v3.0, November 2013
:data-uri:
:toc2:
:icons:
:numbered:

[[chap-Introduction]]

== Introduction

OpenShift  cartridges are a mechanism to encapsulate application components, for example language runtimes, middleware, and databases, and expose them as services so developers can use them to create applications. OpenShift  provides a set of default cartridges for various web programming languages and frameworks, for example Java, PHP, Ruby, Python, Node.js, and Perl. It also provides default cartridges for databases and other types of services, for example MySQL, PostgreSQL, Jenkins CI server and client, Cron, and the HAProxy load balancer. 

A developer begins creating an application in OpenShift  by selecting a web framework cartridge for the desired programming language. Web framework cartridges handle HTTP requests and serve web pages or business APIs. The OpenShift  servers route traffic to the application's web cartridge, where the developer's code runs. The developer can add further cartridges, for example a database or a build server, to provide additional capabilities to the application. OpenShift  also provides embedded cartridges to support other cartridges, for example the phpMyAdmin cartridge for managing a MySQL database. 

The OpenShift  cartridge model enables choice in application technology while reducing the effort of integrating various application components. OpenShift  cartridges encapsulate standard application runtimes and binaries and contain an implementation of the life cycle events required to run the software. For example, cartridges implement commands to start, stop, and scale applications. Cartridge configuration and setup is convention based, with an emphasis on minimizing external dependencies in the cartridge code. 

OpenShift  cartridges are extensible, and custom cartridges can be created to integrate application components that are not supported with the available cartridges. This document provides guidelines and specifications about OpenShift  cartridges, and it is intended for developers who are interested in creating custom cartridges. 


[[chap-Managed_Files]]

== Managed Files

Managed files are files that have non-default settings, or that require special handling by OpenShift . 

The `$cartridge_name/metadata/managed_files.yml` file lists managed files and strings that OpenShift  uses during different stages of the cartridge life cycle. 

*File Patterns*  +
Most entries in the `managed_files.yml` file use file patterns. OpenShift  treats these patterns like shell globs. `Dir.glob` processes entries that contain asterisk (*) symbols using the +File::FNM_DOTMATCH+ flag. It treats entries that end in a forward slash (/) as directories, and other entries as files. For more information on globs, see link:$$http://ruby-doc.org/core-1.9.3/Dir.html#method-c-glob$$[]. 



Entries that begin with ~/ start at the gear directory. All other entries start at the cartridge directory. 

*Strings*  +
Some entries allow string values. These values return directly without any modification. 



*Allowed Entries*  +
OpenShift  supports the following entries: 



.Managed File Entries
[options="header"]
|===============
|
						Entry  | Type | Usage |Reference
					
|
						locked_files
					|
						File Pattern
					|
						Files that the application developer can read but not update.
					|<<chap-Locking_Cartridges>>
|
						snapshot_exclusions
					|
						File Pattern
					|
						Array of file names not to backup from the gear when _rhc snapshot_ runs.
					|<<Backing_Up_and_Restoring_Cartridges>>
|
						setup_rewritten
					|
						File Pattern
					|
						Files that OpenShift  removes before running +setup+.
					|<<binsetup1>>
|
						process_templates
					|
						File Pattern
					|
						ERB templates OpenShift  renders after running +setup+.
					|<<ERB_Processing1>>
|
						restore_transforms
					|
						Strings
					|
						Set of regex transforms for rewriting file names when _rhc restore_ runs.
					|<<Backing_Up_and_Restoring_Cartridges>>

|===============

The following example demonstrates the structure of a basic `managed_files.yml` file: 

.managed_files.yml
====

----

locked_files:
- env/
- ~/.foorc
snapshot_exclusions:
- mydir/*
restore_transforms:
- s|${OPENSHIFT_GEAR_NAME}/data|app-root/data|
process_templates:
- **/*.erb
setup_rewritten:
- conf/*

----


====


[[chap-Locking_Cartridges]]

== Locking Cartridges

Cartridge instances on a gear are either _locked_ or _unlocked_ at any given time. Locking a cartridge enables cartridge scripts to have greater access to the gear's files and directories. Application developers have read and write access to unlocked files, and read-only access to locked files. This means that application scripts and hooks cannot override cartridge code when the cartridge is locked. 

OpenShift  controls the lock state of cartridges, moving them between locked and unlocked at various points in the cartridge life cycle. 

A cartridge with no +locked_files+ entry in the `$cartridge_name/metadata/managed_files.yml` file is permanently unlocked. This approach is not recommended, but it may be sufficient for simple cartridges. 


[NOTE]
====
Cartridge file locking is not a security measure. It is designed to prevent application developers from accidentally breaking their applications by modifying cartridge files. 


====

[[Lock_Configuration1]]


=== Cartridge Lock Configuration

The +locked_files+ entry in the `$cartridge_name/metadata/managed_files.yml` file lists files and directories that OpenShift  locks at certain points during the cartridge life cycle. 

If a file in the +locked_files+ list does not exist, OpenShift  creates the file before your +setup+ script is called. OpenShift  also creates missing directories if required. 

If files require application developers to have read and write access to them while an application is deploying and running, do not allow OpenShift  to create them from the +locked_files+ list. For example, create `~/.node-gyp` and `~/.npm` in a node.js cartridge using a +setup+ or +install+ script. 

Entries that begin with ~/ start at the gear directory. All other entries start at the cartridge directory. Entries that end with a forward slash (/) are treated as directories. Entries that end with an asterisk (*) are treated as lists of files. Entries that end with any other character are treated as files. 


[NOTE]
====
OpenShift  does not change entry types. For example, if you enter a directory without a forward slash (/) at the end, OpenShift  treats it as a file. A cartridge can fail to operate if its +locked_files+ entries are not accurate. 


====


.PHP locked_files Configuration Entry
====

----
locked_files: 	
- ~/.pearrc	<1>
- bin/		<2>
- conf/*	<3>

----
<1>  `~/.pearrc`: when locked, you can edit this file but application developers cannot.
<2> `php/bin/`: the directory is locked but not the files it contains. Only you can add files to the directory, but both you and application developers can edit those files.
<3> `php/conf/*`: the directory is not locked, but the files in the directory are locked. Both you and application developers can add files to the directory, but only you can edit them.

====

*Reserved Files*  +
All visible files and directories in a gear's home directory are reserved. Certain hidden files are also reserved. While a cartridge is unlocked, you can create any unreserved hidden file or directory in the gear's home directory. 


List of reserved hidden files:

- `~/.ssh`


- `~/.sandbox`


- `~/.tmp`


- `~/.env`

[[chap-Exposing_Services]]

== Exposing Services

Most cartridges provide services by binding to ports. Cartridges must declare to which ports they bind, and provide variable names to describe: 


*  The IP addresses provided to the cartridge for binding. 
*  The local gear ports to which the cartridge services bind. 
*  (Optional) The public proxy ports that expose local gear ports for communication between related gears in an application, such as the TCP proxy public endpoint. 
*  (Optional) TCP endpoint mappings that establish a front end for application users. 

[[TCP_Endpoints]]

=== TCP Endpoints

TCP endpoints are services that are exposed by a cartridge, and are accessible by other cartridges or gears in an application. They may be any protocol which uses TCP, such as +http+ or +mysql+. These services may also be exposed to application users through mappings.  OpenShift only creates endpoint ports for scalable applications. 

The endpoints can be defined in the +Endpoints+ section of the `$cartridge_name/metadata/manifest.yml` file. 

.Endpoints Entry
====

----

Endpoints:
  - Private-IP-Name:   <name of IP variable>
    Private-Port-Name: <name of port variable>
    Private-Port:      <port number>
    Public-Port-Name:  <name of public port variable>
    Protocols:         [<protocol type 1>,<protocol type 2>]
    Mappings:
      - Frontend:      "<frontend path>"
        Backend:       "<backend path>"
        Options:       { ... }
      - <...>
  - <...>

----

====

When a cartridge is installed on a gear, it automatically assigns IP addresses to each IP variable name ensuring that assigned addresses can bind to the specified port. 

If an endpoint specifies a public port variable, a public port proxy mapping is created using a random external port accessible through the gear's DNS entry. 

*Endpoint Environment Variables*  +
Endpoint values are exposed to cartridge scripts and application code through environment variables. These environment variables are formed from the +Cartridge-Short-Name+ element and from the endpoint variable names specified in the `manifest.yml` file. 

.Environment Variable Format
====

----

OPENSHIFT_{Cartridge-Short-Name}_{name of IP variable}          => <assigned internal IP>
OPENSHIFT_{Cartridge-Short-Name}_{name of port variable}        => <endpoint specified port>
OPENSHIFT_{Cartridge-Short-Name}_{name of public port variable} => <assigned external port>

----

====

*Endpoint Protocols*  +
You can define the protocols for services using the +Protocols+ variable. +Protocols+ takes a comma-separated list of protocol types from the following available options: 

.Endpoint Protocols
[options="header"]
|===============
|Protocol |Description
					
|tcp
|TCP
					
|http
|HTTP
					
|https
|HTTP Secure (HTTP over SSL/TLS)
					
|ws
|WebSocket
					
|wss
|WebSocket Secure (WebSocket over SSL/TLS)
					
|tls
|SNI Proxy
					
|mongodb
|MongoDB
					
|mysql
|MySQL
					
|postgresql
|PostgreSQL
					
|===============

If the +Protocols+ list is not set, the default behavior matches the pre-+Protocols+ behavior. For example, if an endpoint has +Mappings+, assume HTTP; otherwise, assume TCP. The front-end modules also translate +Mappings+ options. For example, if a +Mappings+ entry has +websocket+ set in its +Options+, then +ws+ is added to the +Protocols+ list. 

*Endpoint Mappings*  +
If an endpoint specifies +Mappings+, a front-end +httpd+ route to the cartridge is created for each mapping entry using the provided options. The +Frontend+ key is a front-end path element connected to a back-end URI specified by the +Backend+ key. The +Options+ hash enables additional route configuration options. 

.Endpoint Mapping Options
[options="header"]
|===============
|Option |Description
					
|websocket
|Enable WebSocket on a particular path
					
|gone
|Mark the path as gone (URI is ignored)
					
|forbidden
|Mark the path as forbidden (URI is ignored)
					
|noproxy
|Mark the path as not proxied (URI is ignored)
					
|redirect
|Use redirection to URI instead of proxy (URI must be a path)
					
|file
|Ignore request and load file path contained in URI (must be a path)
					
|tohttps
|Redirect request to HTTPS and use the path contained in the URI (must be a path)
					
|===============


[[Endpoint_Example1]]


=== TCP Endpoint Example

This section provides an example +Endpoints+ entry in a `$cartridge_name/metadata/manifest.yml` file, and demonstrates how  OpenShift uses this entry to create environment variables, public proxy port mappings, and +httpd+ routes. 

.Endpoints Entry
====

----

Name: CustomCart
Cartridge-Short-Name: CUSTOMCART

...

Endpoints:
  - Private-IP-Name:   HTTP_IP
    Private-Port-Name: WEB_PORT
    Private-Port:      8080
    Public-Port-Name:  WEB_PROXY_PORT
    Protocols:         [ws]
    Mappings:
      - Frontend:      "/web_front"
        Backend:       "/web_back"
      - Frontend:      "/socket_front"
        Backend:       "/socket_back"
        Options:       { "websocket": true }

  - Private-IP-Name:   HTTP_IP
    Private-Port-Name: ADMIN_PORT
    Private-Port:      9000
    Public-Port-Name:  ADMIN_PROXY_PORT
    Protocols:         [http]
    Mappings:
      - Frontend:      "/admin_front"
      - Backend:       "/admin_back"

  - Private-IP-Name:   INTERNAL_SERVICE_IP
    Private-Port-Name: 5544
    Public-Port-Name:  INTERNAL_SERVICE_PORT

----

====

*Environment Variables*  +
Several environment variables are created for the cartridge using the information in the +Endpoints+ entry. 

.Environment Variables
====

----

# Internal IP/port allocations
OPENSHIFT_CUSTOMCART_HTTP_IP=<assigned internal IP 1>
OPENSHIFT_CUSTOMCART_WEB_PORT=8080
OPENSHIFT_CUSTOMCART_ADMIN_PORT=9000
OPENSHIFT_CUSTOMCART_INTERNAL_SERVICE_IP=<assigned internal IP 2>
OPENSHIFT_CUSTOMCART_INTERNAL_SERVICE_PORT=5544

# Public proxy port mappings
OPENSHIFT_CUSTOMCART_WEB_PROXY_PORT=<assigned public port 1>
OPENSHIFT_CUSTOMCART_ADMIN_PROXY_PORT=<assigned public port 2>

----

====

*Proxy Port Mapping*  +
Proxy port mapping is assigned using the information in the +Endpoints+ entry. 

.Proxy Port Mapping
====

----

<assigned external IP>:<assigned public port 1> => OPENSHIFT_CUSTOMCART_HTTP_IP:OPENSHIFT_CUSTOMCART_WEB_PORT
<assigned external IP>:<assigned public port 2> => OPENSHIFT_CUSTOMCART_HTTP_IP:OPENSHIFT_CUSTOMCART_ADMIN_PORT

----

====

*httpd Routing*  +
The +httpd+ routes are assigned using the +Endpoints+ entry. 

.httpd Routing
====

----

http://<app dns>/web_front    => http://OPENSHIFT_CUSTOMCART_HTTP_IP:8080/web_back
http://<app dns>/socket_front => http://OPENSHIFT_CUSTOMCART_HTTP_IP:8080/socket_back
http://<app dns>/admin_front  => http://OPENSHIFT_CUSTOMCART_HTTP_IP:9000/admin_back

----

====


[[Custom_HTTP_Services1]]

=== Custom HTTP Services

With ERB templates you can expose cartridge services using an application's URL by placing Apache configuration code  in the `httpd.d` directory. 

After OpenShift  runs the cartridge +setup+ script, it processes each ERB template and writes the contents of the node's +httpd+ configuration. 

.A mongodb.conf.erb File
====

----

Alias /health <%= ENV['OPENSHIFT_HOMEDIR'] + "/mongodb/httpd.d/health.html" %>
Alias / <%= ENV['OPENSHIFT_HOMEDIR'] + "/mongodb/httpd.d/index.html" %>

----

====


[[chap-Creating_Template_Directories_for_Language_Cartridges]]

== Creating Template Directories for Language Cartridges

Use the `$cartridge_name/template/` or `$cartridge_name/template.git/` directory to provide an basic example of an application written in the language or framework your cartridge packages. Welcome the application developer to your cartridge and inform them that the cartridge is operating correctly. 

If you provide a `$cartridge_name/template.git/` directory, OpenShift  copies the directory for the application developer. 

If you provide a `$cartridge_name/template/` directory, OpenShift  uses it to create a git repository for the application developer. Ensure that your +setup+ and +install+ scripts account for the path change from `template` to `template.git`.

Create `.gitignore` files in empty directories to ensure the directories are retained when OpenShift  builds the git repository. 

.Ruby Template Directory
====

----

A Ruby 1.8 cartridge with Passenger support has a `template/public/` directory and a `config.ru` file to define the web application.
		
+- template
|  +- config.ru
|  +- public
|  |  +- .gitignore
|  .openshift
|  +- markers
|  |- ...

----


====

[[Marker_Files]]


=== Marker Files

The `$cartridge_name/template/.openshift/markers/` directory contains example marker files for application developers. These files set conditions for various stages of a cartridge's life cycle. You can add marker files as required to enable application developers to control aspects of your cartridge. 

.Ruby 1.8 Marker Files
[columns="2*", options="header"]
|===============

| Marker | Action
						
|force_clean_build
|OpenShift  removes previous output from the +bundle install --deployment+ command and reinstalls all gems according to the current `Gemfile` and `Gemfile.lock` files.
						
|hot_deploy 
|OpenShift  serves new application code without restarting the application's web server.
						
|disable_auto_scaling
 |OpenShift  does not automatically scale a scalable application.
						
|===============

[[Application_Developer_Action_Hooks1]]

=== Action Hooks

The `$cartridge_name/template/.openshift/action_hooks/` directory contains examples of application developer action hooks that run during the cartridge life cycle. 

.Action Hooks
====

----

pre_start_`cartridge name`
post_start_`cartridge name`
pre_stop_`cartridge name`

----

====

OpenShift  runs default +action_hooks+ as indicated in the+control+ script. To add additional hooks, run them explicitly in the+control+script. Ensure appropriate documentation is available for application developers to use the additional hooks correctly. 

If you find that the action_hooks are not working, they may not be executable. To fix this, run the following command:  +
`$ git update-index --chmod=+x .openshift/action_hooks/<file_name>`

The +--chmod=(+/-)x+ command sets the execute permissions on the updated file specified. 

 
[[chap-Using_Cartridge_Scripts]]

== Using Cartridge Scripts

Cartridge scripts act as the application programming interface (API) for a cartridge. Use these scripts to contain the required code for single version software that configures easily. For complex configurations and software with multiple versions, use these scripts as shim code to set up the required environment and run additional scripts. You can also create symbolic links from these scripts. 

Cartridge scripts are located in the `$cartridge_name/bin/` directory, and run from the cartridge's home directory. 

.Required Scripts
[options="header"]
|===============
|Script Name |Usage
					
|setup
|Creates and configures files that OpenShift  copies from the cartridge repository to the gear's directory. Runs for the initial installation and every upgrade.
					
|control
|Enables OpenShift  or the application developer to control the state of a cartridge and its packaged software.

|===============


.Optional Scripts
[options="header"]
|===============
|Script Name |Usage
					
|teardown
|Prepares the gear for cartridge removal.
					
|install
|Creates and configures files that OpenShift  copies from the cartridge repository to the gear's directory. Runs only on the first installation of the cartridge.
					
|post-install
|Configures the cartridge after the cartridge starts. Runs only on the first installation of the cartridge.
					
|===============

[[ERB_Processing1]]


=== Embedded Ruby (ERB) Processing

Embedded Ruby (ERB) is a templating system that embeds Ruby into a text document. To provide more flexible configuration and environment variable options, OpenShift  enables you to provide certain values as ERB templates. For more information on ERB templates, see link:$$http://ruby-doc.org/stdlib-1.9.3/libdoc/erb/rdoc/ERB.html$$[]. 

OpenShift  renders ERB templates at +safe_level 2+ and processes them in two passes. For more information on Ruby safe levels, see link:$$http://www.ruby-doc.org/docs/ProgrammingRuby/html/taint.html$$[]. 

.  The first pass processes entries in the `cartridge_name/env/` directory. This pass is mandatory, and occurs before OpenShift  runs the `$cartridge_name/bin/setup` script. 

.  The second pass processes entries specified in the +process_templates+ entry of the `$cartridge_name/metadata/managed_files.yml` file. This pass occurs after OpenShift  runs the +cartridge_name/bin/setup+ script, but before it runs the +$cartridge_name/bin/install+ script. This enables the +setup+ script to create or modify ERB templates as required, and for the +install+ script to use the processed values. 

.Environment Variable Template
====

An env/OPENSHIFT_MONGODB_DB_LOG_DIR.erb file contains: 

----
erb   <% ENV['OPENSHIFT_HOMEDIR'] + "/mongodb/log/" %>
----
		
From that ERB file, OpenShift  creates an +env/OPENSHIFT_MONGODB_DB_LOG_DIR+ environment variable containing: 

----
/var/lib/openshift/aa9e0f66e6451791f86904eef0939e/mongodb/log/
----
		
====

._php.ini_ Configuration Template
====

A `conf/php.ini.erb` file contains: 

----
erb   upload_tmp_dir = "<%= ENV['OPENSHIFT_HOMEDIR'] %>php/tmp/"   session.save_path = "<%= ENV['OPENSHIFT_HOMEDIR'] %>php/sessions/"
----
		
From that ERB file, OpenShift  creates a `conf/php.ini` file containing: 

----
upload_tmp_dir = "/var/lib/openshift/aa9e0f66e6451791f86904eef0939e/php/tmp/"
----
----
session.save_path = "/var/lib/openshift/aa9e0f66e6451791f86904eef0939e/php/sessions/"
----
		
====

Other possible uses for ERB templates are +includes+ values in +httpd+ configuration files, database configuration values for storing persistent data in the `OPENSHIFT_DATA_DIR` directory, and the application name value in the `pom.xml` file. 

[[binsetup1]]


=== setup Script

*Synopsis*  +
+setup+ [--version <version>]
				 
*Options*  +
+--version <version>+: selects which version of the cartridge to install. If you do not supply a version, OpenShift  installs the version given in the +Version+ element of the `$cartridge_name/metadata/manifest.yml` file. 

*Description*  +
The +setup+ script creates and configures files that OpenShift  copies from the cartridge repository to the gear's directory. The +setup+ script must be re-entrant. OpenShift  runs the script for every upgrade that is not backward compatible. Add logic you want to run only once to the +install+ script, not the +setup+ script. 

Add files created during setup to the +setup_rewritten+ section of the `$cartridge_name/metadata/managed_files.yml` file. During an upgrade, OpenShift  deletes these files prior to running the +setup+ script. 

If you use ERB templates to configure software, OpenShift  processes these files for environment variable substitution after running the +setup+ script. 

_Lock context: unlocked._ 

[[bininstall1]]

=== install Script

*Synopsis*  +
+install+ [--version <version>]
				 
*Options* +
+--version <version>+: selects which version of the cartridge to install. If you do not supply a version, OpenShift  installs the version given in the +Version+ element of the `$cartridge_name/metadata/manifest.yml` file. 

*Description*  +
The +install+ script creates and configures files that OpenShift  copies from the cartridge repository to the gear's directory. OpenShift  runs the +install+ script only on the first installation of a cartridge. 

Put logic for one-time operations, for example generating passwords, creating ssh keys, and adding environment variables, in the +install+ script. 

Report client results and messages with the +install+ script, not the +setup+ script. 

The +install+ script may substitute a version dependent of the `template` or `template.git` directories. 

_Lock context: unlocked._ 


[[binpost-install1]]

=== post-install Script

*Synopsis*  +
+post-install+ [ --version <version> ]
				 
*Options* +
+--version <version>+: selects which version of the cartridge to install. If you do not supply a version, OpenShift  installs the version given in the +Version+ element of the `$cartridge_name/metadata/manifest.yml` file. 

*Description*  +
Use the +post-install+ script to configure your cartridge after the cartridge starts. OpenShift  only runs the +post-install+ script for the first installation of the cartridge. 

_Lock context: locked._ 


[[binteardown1]]

=== teardown Script

*Synopsis* +
+teardown+

*Description* +
 The +teardown+ script prepares the gear for cartridge removal. The script only runs when OpenShift  removes the cartridge from a gear; it does not run when OpenShift  deletes the gear. The gear continues to operate without the functionality of the removed cartridge. 

_Lock context: unlocked._ 


[[bincontrol1]]

=== control Script

*Synopsis* +
+control <action>+

*Options* +
+<action>+: the action the cartridge performs. 

*Description*  +
The +control+ script enables OpenShift or the application developer to control the state of a cartridge and its packaged software. 

.Control Script Actions
[options="header"]
|===============
|Action |Result
					
|update-configuration, pre-build, build, deploy, post-deploy
|See <<chap-OpenShift_Build_Process>>.
					
|start
|Starts the software the cartridge controls.
					
|stop
|Stops the software the cartridge controls.
					
|status
|Returns a zero (0) exit status if the cartridge code is running.
					
|reload
|Instructs the cartridge and its packaged software to reload their configuration information. This action only operates if the cartridge is running.
					
|restart
|Stops the current process and starts a new one for the packaged software.
					
|threaddump
|Signals the packaged software to perform a thread dump, if applicable.
					
|tidy
|Releases unused resources.
					
|pre-snapshot
|Prepares the cartridge for a snapshot.
					
|post-snapshot
|Tidies the cartridge after a snapshot.
					
|pre-restore
|Prepares the cartridge for restoration.
					
|post-restore
|Tidies the cartridge after restoration.
					
|===============

_Lock context: locked._ 

*Using the tidy Action*  +
By default, the +tidy+ action performs the following operations:  

*  Garbage collects the Git repository. 
*  Removes all files in the `/tmp` directory. 

Add additional operations to the +tidy+ action by editing the +tidy()+ function in the `$cartridge_name/bin/control` file. Because applications have limited resources, it is recommended that you tidy thoroughly. 

.Additional _tidy_ Operations
====

----
rm $OPENSHIFT_{Cartridge-Short_Name}_DIR/logs/log.[0-9]
				
cd $OPENSHIFT_REPO_DIR ; mvn clean
				
----

====

*Using the status Action*  +
When an application developer queries the status of your packaged software, use a zero (0) exit status to indicate correct operation. Direct information to the application developer using +stdout+. Return errors with a non-zero exit status using +stderr+. 

OpenShift maintains the expected state of an application in the `~/app-root/runtime/.state` file. Do not use this file to determine the status of the packaged software as it contains the expected state of the application, not the current state. 

.Values for _.state_
[options="header"]
|===============
|Value |Status
					
|building
|Application is building.
					
|deploying
|Application is deploying.
					
|idle
|Application is shutdown due to inactivity.
					
|new
|A gear exists, but no application is installed.
					
|started
|Application started.
					
|stopped
|Application is stopped.
					
|===============


[[Exit_Status_Codes]]

=== Exit Status Codes

OpenShift  follows the convention that scripts return zero (0) for success and non-zero for failure. 

OpenShift  supports special handling of several non-zero exit codes. These codes enable OpenShift  to refine its behavior, for example when returning `HTTP` status codes through the REST API or when deciding whether to continue or abort an operation. 

If a cartridge script returns a value not included in the following tables, OpenShift  treats the error as fatal to the cartridge. 

.User Errors
[options="header"]
|===============
|Exit Code |Usage
					
|
						1
					|
						Non-specific error
					
|
						97
					|
						Invalid user credentials
					
|
						99
					|
						User does not exist
					
|
						100
					|
						An application with specified name already exists
					
|
						101
					|
						An application with specified name does not exist and cannot be operated on
					
|
						102
					|
						A user with login already exists
					
|
						103
					|
						Given namespace is already in use
					
|
						104
					|
						User's gear limit has been reached
					
|
						105
					|
						Invalid application name
					
|
						106
					|
						Invalid namespace
					
|
						107
					|
						Invalid user login
					
|
						108
					|
						Invalid SSH key
					
|
						109
					|
						Invalid cartridge types
					
|
						110
					|
						Invalid application type specified
					
|
						111
					|
						Invalid action
					
|
						112
					|
						Invalid API
					
|
						113
					|
						Invalid auth key
					
|
						114
					|
						Invalid auth iv
					
|
						115
					|
						Too many cartridges of one type per user
					
|
						116
					|
						Invalid SSH key type
					
|
						117
					|
						Invalid SSH key name or tag
					
|
						118
					|
						SSH key name does not exist
					
|
						119
					|
						SSH key or key name not specified
					
|
						120
					|
						SSH key name already exists
					
|
						121
					|
						SSH key already exists
					
|
						122
					|
						Last SSH key for user
					
|
						123
					|
						No SSH key for user
					
|
						124
					|
						Could not delete default or primary key
					
|
						125
					|
						Invalid template
					
|
						126
					|
						Invalid event
					
|
						127
					|
						A domain with specified namespace does not exist and cannot be operated on
					
|
						128
					|
						Could not delete domain because domain has valid applications
					
|
						129
					|
						The application is not configured with this cartridge
					
|
						130
					|
						Invalid parameters to estimates controller
					
|
						131
					|
						Error during estimation
					
|
						132
					|
						Insufficient Access Rights
					
|
						133
					|
						Could not delete user
					
|
						134
					|
						Invalid gear profile
					
|
						135
					|
						Cartridge not found in the application
					
|
						136
					|
						Cartridge already embedded in the application
					
|
						137
					|
						Cartridge cannot be added or removed from the application
					
|
						138
					|
						User deletion not permitted for normal or non-subaccount user
					
|
						139
					|
						Could not delete user because user has valid domain or applications
					
|
						140
					|
						Alias already in use
					
|
						141
					|
						Unable to find nameservers for domain
					
|
						150
					|
						A plan with specified id does not exist
					
|
						151
					|
						Billing account was not found for user
					
|
						152
					|
						Billing account status not active
					
|
						153
					|
						User has more consumed gears than the new plan allows
					
|
						154
					|
						User has gears that the new plan does not allow
					
|
						155
					|
						Error getting account information from billing provider
					
|
						156
					|
						Updating user plan on billing provider failed
					
|
						157
					|
						Plan change not allowed for subaccount user
					
|
						158
					|
						Domain already exists for user
					
|
						159
					|
						User has additional filesystem storage that the new plan does not allow
					
|
						160
					|
						User max gear limit capability does not match with current plan
					
|
						161
					|
						User gear sizes capability does not match with current plan
					
|
						162
					|
						User max untracked additional filesystem storage per gear capability does not match with current plan
					
|
						163
					|
						Gear group does not exist
					
|
						164
					|
						User is not allowed to change storage quota
					
|
						165
					|
						Invalid storage quota value provided
					
|
						166
					|
						Storage value not within allowed range
					
|
						167
					|
						Invalid value for +nolinks+ parameter
					
|
						168
					|
						Invalid scaling factor provided. Value out of range.
					
|
						169
					|
						Could not completely distribute +scales_from+ to all groups
					
|
						170
					|
						Could not resolve DNS
					
|
						171
					|
						Could not obtain lock
					
|
						172
					|
						Invalid or missing private key is required for SSL certificate
					
|
						173
					|
						Alias does exist for this application
					
|
						174
					|
						Invalid SSL certificate
					
|
						175
					|
						User is not authorized to add private certificates
					
|
						176
					|
						User has private certificates that the new plan does not allow
					
|
						180
					|
						This command is not available in this application
					
|
						181
					|
						User maximum tracked additional filesystem storage per gear capability does not match with current plan
					
|
						182
					|
						User does not have +gear_sizes+ capability provided by current plan
					
|
						183
					|
						User does not have +max_untracked_addtl_storage_per_gear+ capability provided by current plan
					
|
						184
					|
						User does not have +max_tracked_addtl_storage_per_gear+ capability provided by current plan
					
|
						185
					|
						Cartridge +X+ can not be added without cartridge +Y+
|
						186
					|
						Invalid environment variables: expected array of hashes.
					
|
						187
					|
						Invalid environment variable +X+. Valid keys name (required), +value+
|
						188
					|
						Invalid environment variable name +X+: specified multiple times
					
|
						189
					|
						Environment name +X+ not found in application
					
|
						190
					|
						Value not specified for environment variable +X+
|
						191
					|
						Specify parameters +name/value or environment_variables+
|
						192
					|
						Environment name +X+ already exists in application
					
|
						193
					|
						Environment variable deletion not allowed for this operation
					
|
						194
					|
						Name can only contain letters, digits and underscore and cannot begin with a digit
					
|
						210
					|
						Cannot override existing location for git repository
					
|
						211
					|
						Parent directory for git repository does not exist
					
|
						212
					|
						Could not find `libra_id_rsa`
|
						213
					|
						Could not read from SSH configuration file
					
|
						214
					|
						Could not write to SSH configuration file
					
|
						215
					|
						Host could not be created or found
					
|
						216
					|
						Error in git pull
					
|
						217
					|
						Destroy aborted
					
|
						218
					|
						Not found response from request
					
|
						219
					|
						Unable to communicate with server
					
|
						220
					|
						Plan change is not allowed for this account
					
|
						221
					|
						Plan change is not allowed at this time for this account. Wait a few minutes and try again. If problem persists contact Red Hat support.
					
|
						253
					|
						Could not open configuration file
					
|
						255
					|
						Usage error
					

|===============


.Uncommon Server Errors
[options="header"]
|===============
|Exit Code |Usage
					
|
						140
					|
						No nodes available. If the problem persists contact Red Hat support.
					
|
						141
					|
						Cartridge exception.
					
|
						142
					|
						Application is registered to an invalid node. If the problem persists contact Red Hat support.
					
|
						143
					|
						Node execution failure. If the problem persists contact Red Hat support.
					
|
						144
					|
						Error communicating with user validation system. If the problem persists contact Red Hat support.
					
|
						145
					|
						Error communicating with DNS system. If the problem persists contact Red Hat support.
					
|
						146
					|
						Gear creation exception.
					
|===============


[[Messaging_to_OpenShift__from_Cartridge]]

=== Communication Between OpenShift and Cartridges

A cartridge can provide services for use by multiple gears in one application. OpenShift  enables you to publish these services. Each message writes to +stdout+ or +stderr+ with an exit status, one message per line. 

.Service Messages
====

----
ENV_VAR_ADD: <variable name>=<value>
CART_DATA: <variable name>=<value>
CART_PROPERTIES: <key>=<value>
APP_INFO: <value>
		
----

====

[[chap-Environment_Variables]]

== Environment Variables

OpenShift  uses environment variables to communicate information between cartridges, applications, and the system. 

OpenShift  provides several system environment variables that are available for use at all cartridge entry points. 

Place cartridge environment variables in the `$cartridge_name/env/` directory. OpenShift  loads cartridge variables after system environment variables, but before calling your code. 

[[System_Provided_Variables_Read_Only1]]


=== System Environment Variables

OpenShift  provides several system environment variables. These variables are read-only. 

.System Environment Variables
[options="header"]
|===============
|Name |Value
					
|
						HOME
					|
						Alias for +OPENSHIFT_HOMEDIR+.
					
|
						HISTFILE
					|
						Bash history file.
					
|
						OPENSHIFT_APP_DNS
					|
						The fully qualified domain name of the application using your cartridge.
					
|
						OPENSHIFT_APP_NAME
					|
						The name of the application using your cartridge. Assigned by the application developer.
					
|
						OPENSHIFT_APP_UUID
					|
						The UUID of the application using your cartridge. Assigned by OpenShift .
					
|
						OPENSHIFT_DATA_DIR
					|
						The directory where the application and your cartridge store data.
					
|
						OPENSHIFT_GEAR_DNS
					|
						The fully qualified domain name of the gear where your cartridge is installed. This may not be the same as +OPENSHIFT_APP_DNS)+.
					
|
						OPENSHIFT_GEAR_NAME
					|
						The name of the gear where your cartridge is installed. Assigned by OpenShift . This may not be the same as +OPENSHIFT_APP_NAME)+.
					
|
						OPENSHIFT_GEAR_UUID
					|
						The UUID of the gear where your cartridge is installed. Assigned by OpenShift .
					
|
						OPENSHIFT_HOMEDIR
					|
						The home directory of the gear where your cartridge is installed. Assigned by OpenShift .
					
|
						OPENSHIFT_REPO_DIR
					|
						The directory where the application repository is stored. OpenShift  runs the application from this location.
					
|
						OPENSHIFT_TMP_DIR
					|
						The directory where the application and your cartridge store temporary data.
					
|
						TMP
					|
						Alias for +OPENSHIFT_TMP_DIR+.
					
|
						TMPDIR
					|
						Alias for +OPENSHIFT_TMP_DIR+.
					
|===============

[[System_Provided_Cartridge_Variables_Read_Only1]]

=== Cartridge Environment Variables

OpenShift  provides three environment variables for all cartridges by default. These variables are read-only. 

.Cartridge Environment Variables
[options="header"]
|===============
|Name |Value
					
|OPENSHIFT_{Cartridge-Short-Name}_DIR
|The directory where cartridge information is installed.
					
|OPENSHIFT_{Cartridge-Short-Name}_IDENT
|The identity of the cartridge, sourced from its `manifest.yml` file. The format is `Cartridge-Vendor:Version:Cartridge-Version`.
					
|OPENSHIFT_PRIMARY_CARTRIDGE_DIR
|The directory where the primary cartridge on a gear is installed. For example, a scaling PHP application has both a PHP cartridge and a HAProxy cartridge installed on the head gear. In this case, the PHP cartridge is the primary cartridge.
					
|===============

[[Examples_of_Cartridge_Variables1]]


=== Custom Cartridge Environment Variables

You can add custom environment variables to a cartridge by adding them to the cartridge's `$cartridge_name/env/` directory or creating them with the cartridge's +setup+ and +install+ scripts. 

Entries in a cartridge's `$cartridge_name/env/` directory do not override system-provided environment variables. Using system-provided environment variable names in the `$cartridge_name/env/` directory prevents the cartridge from installing correctly. 

Prefix custom environment variables with `OPENSHIFT_{cartridge short name}` to prevent overwriting other cartridge variables in the packaged software's process environment space. 

Suffix directory environment variables with +_DIR+ and the value with a backslash (/). 

You can provide Embedded Ruby (ERB) templates for environment variables in the `$cartridge_name/env/` directory. OpenShift  processes ERB templates in this directory before calling the cartridge's +setup+ script. 

OpenShift  sets the PATH variable using the path `/etc/openshift/env/PATH`. If you provide an +OPENSHIFT_{Cartridge-Short-Name}_PATH_ELEMENT+, OpenShift  uses the value to build the +PATH+ when your scripts run or an application developer performs an interactive log on. 


[IMPORTANT]
====
OpenShift  does not validate cartridge-provided environment variables. A cartridge can fail to function if its environment variable files contain invalid data. 

====

*Packaged Software Environment Variables*  +
If your cartridge packages software with its own environment variables, add these variables to the cartridge's `$cartridge_name/env/` directory or include them in the shim code of the scripts in the `$cartridge_name/bin/` directory. 

.Jenkins Environment Variables
====

----

JENKINS_URL
JENKINS_USERNAME
JENKINS_PASSWORD
				
----

====


[[chap-Cartridge_Events]]

== Cartridge Events

OpenShift  provides a publish and subscribe system that enables a cartridge to act when a developer adds or removes another cartridge in an application. 

The +Publishes+ and +Subscribes+ elements in the `$cartridge_name/metadata/manifest.yml` file detail support for cartridge events. 

[[Cartridge_Event_Publishing1]]


=== Cartridge Event Publishing

When OpenShift  adds a cartridge to an application, it uses entries in the +Publishes+ section of the `$cartridge_name/metadata/manifest.yml` file to construct events sent to other cartridges in the application. Define publish events in the `manifest.yml` file using the following format:  
----

Publishes:
  <event_name>:
    Type: "<event type>"

----

.PHP Cartridge Publishes Entry

====

----

Publishes:
  get-php-ini:
    Type: "FILESYSTEM:php-ini"
  publish-http-url:
    Type: "NET_TCP:httpd-proxy-info"
  publish-gear-endpoint:
    Type: "NET_TCP:gear-endpoint-info"

----

====

For each +Publishes+ entry, OpenShift  runs a script named `$cartridge_name/hooks/$event_name`. 

OpenShift  joins lines of output that the `hooks/$event_name` script writes to +stdout+ with single spaces, then inputs the result to subscriber scripts in other cartridges that match the +Type+ of the publish event. The input to matching subscriber scripts is prefaced with `hooks/<event_name> <gear_name> <namespace> <gear_uuid>`. 


[[Cartridge_Event_Subscriptions1]]

=== Cartridge Event Subscriptions

When OpenShift  adds a cartridge to an application, it uses entries in the +Subscribes+ section of the `$cartridge_name/metadata/manifest.yml` file in other cartridges to determine what actions to take for those other cartridges. Define subscribe events in the `manifest.yml` file using the following format:  
----

Subscribes:
  <event_name>:
    Type: "<event type>"

----

.PHP Cartridge Subscribes Entry
====

----

Subscribes:
  set-env:
    Type: "ENV:*"
    Required: false
  set-mysql-connection-info:
    Type: "NET_TCP:db:mysql"
    Required: false
  set-postgres-connection-info:
    Type: "NET_TCP:db:postgres"
    Required: false
  set-doc-url:
    Type: "STRING:urlpath"
    Required: false

----

====

When OpenShift  processes a cartridge publish script, it inputs the result to subscriber scripts in other cartridges that match the +Type+ of the publish event. The input to matching subscriber scripts is prefaced with `$cartridge_name/hooks/<event_name> <gear_name> <namespace> <gear_uuid>`. 

For each matching +Subscribes+ entry, OpenShift  runs a script named `$cartridge_name/hooks/$event_name`. OpenShift  must send and process entries marked with +Required: true+. 

The publisher script determines the format of the information input to the subscriber script. Ensure that subscriber script can parse the input correctly. 

[[Cartridge_Event_Example1]]


=== Cartridge Event Example

In this example, an application developer adds a MySQL database cartridge to a PHP application. The publish and subscribe relationship between the cartridges enables the PHP cartridge to set environment variables on its gear so it can connect to the new MySQL cartridge, which is on a different gear. 

*MySQL Cartridge as Publisher*  +
The MySQL cartridge lists a +publish-mysql-connection-info+ event in the +Publishes+ section of its `mysql/metadata/manifest.yml` file:  
----

Publishes:
  publish-mysql-connection-info:
    Type: "NET_TCP:db:mysql"

----

The MySQL cartridge implements a script in `mysql/hooks/publish-mysql-connection-info`. 

*PHP Cartridge as Subscriber*  +
The PHP cartridge lists a +set-mysql-connection-info+ event in the +Subscribes+ section of its `php/metadata/manifest.yml` file:  
----

Subscribes:
  set-mysql-connection-info:
    Type: "NET_TCP:db:mysql"

----

The PHP cartridge implements a script in `php/hooks/set-mysql-connection-info`. 

*Cartridge Event Communication Process*  +
OpenShift  matches the event +Type+ in the PHP cartridge's +Subscribes+ list to the event +Type+ in the MySQL cartridge's +Publishes+ list. In this example, the event +Type+ is +"NET_TCP:db:mysql"+. 

The MySQL cartridge's +publish-mysql-connection-info+ script outputs the username, host, port, URL, and password required to connect to the MySQL instance:  
----

OPENSHIFT_MYSQL_DB_USERNAME=username;
OPENSHIFT_MYSQL_DB_PASSWORD=password;
OPENSHIFT_MYSQL_DB_HOST=hostname;
OPENSHIFT_MYSQL_DB_PORT=port;
OPENSHIFT_MYSQL_DB_URL=url;

----

OpenShift  sends the output of the MySQL cartridge's +publish-mysql-connection-info+ to the PHP cartridge's +set-mysql-connection-info+ script using the following format:  
----

hooks/publish-mysql-connection-info gear_name namespace gear_uuid 'OPENSHIFT_MYSQL_DB_USERNAME=username;OPENSHIFT_MYSQL_DB_PASSWORD=password;OPENSHIFT_MYSQL_DB_HOST=hostname;OPENSHIFT_MYSQL_DB_PORT=port;OPENSHIFT_MYSQL_DB_URL=url;'

----

Note that the publisher script determines the format of the information input to the subscriber script. When writing subscriber scripts, ensure that they parse the input correctly. 



[[chap-OpenShift_Build_Process]]

== OpenShift Build Process

When an application developer pushes changes to an application's Git repository, OpenShift  builds and deploys the application using the updated repository. The build and deploy process changes if the application is scaling or if it uses a builder cartridge. 

[[Default_Build_Lifecycle1]]


=== Default Build Life Cycle

If no builder cartridge is present, OpenShift  executes the default build life cycle when an application developer pushes changes to an application Git repository. The default life cycle consists of a +build+ phase and a +deploy+ phase. 

In the default build life cycle, OpenShift  manages the starting and stopping of the application, and moves the updated code into +$OPENSHIFT_REPO_DIR+. The primary cartridge and application developer action hooks (`OPENSHIFT_REPO_DIR/.openshift/action_hooks`) determine specific behaviors during this process. 

*Build Phase* +

.  OpenShift  stops the application by running the +gear stop+ command. 
.  OpenShift  runs the +control pre-receive+ command for the primary cartridge. 
.  OpenShift  copies the new application source code to +$OPENSHIFT_REPO_DIR+. This is the only point in the build life cycle when OpenShift  copies the application source code. 
.  OpenShift  runs the +control update-configuration+ command for the primary cartridge. 
.  OpenShift  runs the +control pre-build+ command for the primary cartridge. 
.  OpenShift  runs the +pre-build+ user action hook, if present. 
.  OpenShift  runs the +control build+ command for the primary cartridge. 
.  OpenShift  runs the +build+ user action hook, if present. 

*Deploy Phase* +

.  OpenShift  starts all secondary cartridges in the application. 
.  OpenShift  runs the +control deploy+ command for the primary cartridge. 
.  OpenShift  runs the +deploy+ user action hook, if present. 
.  OpenShift  starts the primary cartridge using the +gear start+ command. 
.  OpenShift  runs the +control post-deploy+ command for the primary cartridge. 
.  OpenShift  runs the +post-deploy+ user action hook, if present. 

The build is now complete and the application is running. 


[[Default_Scaling_Build_Lifecycle1]]

=== Default Scaling Build Life Cycle

On the head gear, where the web proxy runs, the build phase for a scalable application is the same as the default build phase for a non-scaling application. The deploy phase for scalable applications is different. 

*Deploy Phase* +

.  OpenShift  starts the secondary cartridges on the application's head gear. 
.  OpenShift  runs the web proxy's +deploy+ hook on the head gear. 
.  The web proxy runs deployment steps on the application's secondary gears. For example, the default web proxy, HAProxy, preforms the following steps: 
.. It stops the secondary gears. 
.. It synchronizes the code and build artifacts from the head gear to the secondary gears. 
.. It runs the primary cartridge's +control update-configuration+ command on the secondary gears. 
..  It starts all the secondary cartridges on the secondary gears. 
..  It runs the primary cartridge's +control deploy+ command on the secondary gears. 
..  It runs the +deploy+ user action hook, if present, on the secondary gears. 
..  It starts the primary cartridge on the secondary gears. The application is now running on the secondary gears. 
..  It runs the primary cartridge's +control post-deploy+ command on the secondary gears. 
..  It runs the +post-deploy+ user action hook, if present, on the secondary gears. 

.  OpenShift  runs the primary cartridge's +control deploy+ command on the head gear. 
.  OpenShift  runs the +deploy+ user action hook, if present, on the head gear. 
.  OpenShift  starts the primary cartridge on the head gear. 
.  OpenShift  runs the primary cartridge's +control post-deploy+ command on the head gear. 
.  OpenShift  runs the +post-deploy+ user action hook, if present, on the head gear. 

The build is now complete, and the scaled application is running. 


[[Builder_Cartridge_Lifecycle1]]

=== Builder Cartridge Life Cycle

If an application includes a builder cartridge, OpenShift  does not perform build tasks. Instead, the builder cartridge runs the build process. 

During the Git +pre-receive+ hook, OpenShift  runs the builder cartridge's +control pre-receive+ command. 

During the Git +post-receive+ hook, OpenShift  runs the builder cartridge's +control post-receive+ command. 


[NOTE]

====
 Build processes use the application developer's gear resources to run. When implementing a builder cartridge, do not copy source code or build artifacts more than necessary. 

====


[[chap-Backing_Up_and_Restoring_Cartridges]]

== Backing Up and Restoring Cartridges

OpenShift  provides +snapshot+ and +restore+ features for user applications. These features enable OpenShift  application developers to: 


*  Snapshot the current state of an application to create a backup. 


*  Restore an application from an archived state. 


*  Copy or rename an application by taking a snapshot, creating a new application, then restoring the snapshot data to the new application. 

[[Understanding_OpenShift__Behavior_Snapshot]]

=== Snapshot

When an application developer runs the +rhc snapshot save+ command, OpenShift  creates an archive of the application using the following steps: 

.  OpenShift  stops the application by running the +gear stop+ command. 

.  OpenShift  runs the +control pre-snapshot+ command for each cartridge on the gear. You can control cartridge serialization in the snapshot by implementing the +control pre-snapshot+ command in conjunction with exclusions. For example, you can snapshot to a database dump instead of a database file. 

.  OpenShift  builds a list of exclusions from the +snapshot_exclusions+ entry in the `$cartridge_name/metadata/managed_files.yml` file for each cartridge on the gear. 

.  OpenShift  creates an archive of the application in +tar.gz+ format and writes it to +stdout+ for use by the client tools. In addition to the files listed in the +snapshot_exclusions+ entry in the `managed_files.yml` file, OpenShift  excludes the following files: 

*  Selected gear user files: `.tmp`, `.ssh`, `.sandbox`. 


*  Application state file: `app-root/runtime/.state`. 


*  Bash history file: `$OPENSHIFT_DATA_DIR/.bash_history`. 


.  OpenShift  runs the +control post-snapshot+ command for each cartridge on the gear. Use this script to cleanup after the snapshot runs. 


.  OpenShift  restarts the application by running the +gear start+ command. 

*Snapshot Exclusions*  +
Use the optional +snapshot_exclusions+ entry in the `$cartridge_name/metadata/managed_files.yml` file to list files to exclude from the snapshot and restore process. File patterns originate from the `OPENSHIFT_HOMEDIR` directory, not the cartridge directory. Do not exclude files that your cartridge requires to operate. 

.snapshot_exclusions Entry

====

----

snapshot_exclusions:
- mydir/*

----

====

OpenShift  uses the +tar+ command when performing snapshots. See the +tar+ man page +--exclude-from+ option for more information. 

[[Understanding_OpenShift__Behavior_Restore]]


=== Restore

When an application developer runs the +rhc snapshot restore+ command, OpenShift  restores the application from an archive as follows: 

.  OpenShift  prepares the application for restoration. 

*  If the archive contains a Git repository, OpenShift  runs the +gear pre-receive+ command. 
*  If the archive does not contain a Git repository, OpenShift  runs the +gear stop+ command. 

.  OpenShift  runs the +control pre-restore+ command for each cartridge on the gear. This enables you to control the restoration of your cartridge, for example by deleting an old database dump. 

.  OpenShift  builds a list of file name changes to apply during the restoration from the +restore_transforms+ entry in the `$cartridge_name/metadata/managed_files.yml` file for each cartridge on the gear. 

.  OpenShift  extracts the archive into the gear user's home directory, overwriting existing files and applying the file name changes listed in the +restore_transforms+ entry in the `managed_files.yml` file. 

.  OpenShift  runs the +control post-restore+ command for each cartridge on the gear. Use this script to load a database flat file into the running database. 

.  OpenShift  resumes the application. 

*  If the archive contains a Git repository, OpenShift  runs the +gear postreceive+ command. 
*  If the archive does not contain a Git repository, OpenShift  runs the +gear start+ command. 

*Restoring with Transformed File Names*  +
Use the optional +restore_transforms+ entry in the `$cartridge_name/metadata/managed_files.yml` file to provide scripts that transform file names when OpenShift  restores an application. This entry enables you to restore older snapshots to a newer cartridge with file name changes. 

.restore_transforms Entry

====

----

restore_transforms:
- s|${OPENSHIFT_GEAR_NAME}/data|app-root/data|

----

====

OpenShift  uses the +tar+ command when restoring a gear. See the +tar+ man page +--transform+ option for more information. 


[[chap-Upgrading_Custom_and_Community_Cartridges]]

== Upgrading Custom and Community Cartridges

The OpenShift  runtime contains a system for upgrading custom cartridges on a gear to the latest available version and for applying gear-level changes that affect cartridges. 

The +oo-admin-upgrade+ command provides the command line interface for the upgrade system and can upgrade all the gears in an OpenShift  environment, all the gears on a node, or a single gear. This command queries the OpenShift  broker to determine the locations of the gears to migrate and uses MCollective calls to trigger the upgrade for a gear. 

*Upgrade Process Overview* +

.  Load the gear upgrade extension, if configured. 
.  Inspect the gear state. 
.  Run the gear extension's +pre-upgrade+ script, if it exists. 
.  Compute the upgrade itinerary for the gear. 
.  If the itinerary contains an incompatible upgrade, stop the gear. 
.  Upgrade the cartridges in the gear according to the itinerary. 
.  Run the gear extension's +post-upgrade+ script, if it exists. 
.  If the itinerary contains an incompatible upgrade, restart and validate the gear. 
.  Clean up after the upgrade by deleting pre-upgrade state and upgrade metadata. 


[[Upgrade_Itinerary]]

=== Upgrade Itinerary

The upgrade process must be re-entrant; if it fails or times out, a subsequent upgrade operation must pick up where the last one left off. The upgrade itinerary stores information about which cartridges in a gear to upgrade and which type of upgrade to perform. 

There are two types of cartridge upgrade processes: compatible and incompatible. The +Compatible-Versions+ element in a cartridge's `$cartridge_name/metadata/manifest.yml` file determines whether the new version is compatible with a previous version. The main difference between the compatible and incompatible upgrade processes is that an incompatible cartridge's gear stops during an upgrade, while a compatible cartridge's gear continues to run. 

*Upgrade Itinerary Configuration* +

.  Read in the current +IDENT+ of the cartridge. 
.  Determine the name and software version of the cartridge in the cartridge repository; this provides the manifest for the latest version of the cartridge. If a manifest does not exist in the cartridge repository or does not include the software version, skip the cartridge. 

.  If the latest manifest is for the same cartridge version as the version currently installed on the gear, skip the cartridge unless the +ignore_cartridge_version+ parameter is set. If the +ignore_cartridge_version+ parameter is set, record an incompatible upgrade for the cartridge in the itinerary. 

.  If the latest manifest includes the current cartridge version in the +Compatible-Versions+ element, record a compatible upgrade for the cartridge in the itinerary. Otherwise, record an incompatible upgrade for the cartridge in the itinerary. 

[[Compatible_Upgrades]]


=== Compatible Upgrades

If the upgrade itinerary records a compatible upgrade for a cartridge, OpenShift  uses the following process: 

*Compatible Upgrades* +

.  Overlay the new version of the cartridge on the gear. 

.  Remove the files declared in the +Processed-Templates+ element of the cartridge's `managed-files.yml` file.

.  Unlock the cartridge directory. 

.  Secure the cartridge directory. 

.  Run the cartridge's +upgrade+ script, if it exists. 

.  Lock the cartridge directory. 

 
[[Incompatible_Upgrades]]


=== Incompatible Upgrades

If the upgrade itinerary records an incompatible upgrade for a cartridge, OpenShift  uses the following process: 

*Incompatible Upgrade Process* +

.  Remove the files and directories declared in the +Setup-Rewritten+ element of the cartridge's `managed_files.yml` file. 
.  Overlay the new version of the cartridge on the gear. 
.  Unlock the cartridge directory. 
.  Secure the cartridge directory. 
.  Run the cartridge's +upgrade+ script, if it exists. 
.  Run the cartridge's +setup+ script. 
.  Process the cartridge's ERB templates. 
.  Lock the cartridge directory. 
.  Create new endpoints for the cartridge. 
.  Connect the frontend. 


[[Cartridge_Upgrade_Script]]

=== Cartridge Upgrade Script

You can provide a cartridge +upgrade+ script in the `$cartridge_name/bin/` directory to run during the upgrade process. The +upgrade+ script enables you to perform actions during the upgrade process that the compatible or incompatible processes do not perform. If you provide an +upgrade+ script, OpenShift  passes it the following arguments: 

*  The software version of the cartridge. 
*  The current cartridge version. 
*  The cartridge version being upgraded to. 

A non-zero exit code from this script results in the upgrade operation failing. 


[[chap-OpenShift_Cartridge_Reference]]

== OpenShift Cartridge Reference

This chapter contains reference material for OpenShift  cartridges. 

[[Cartridge_Directory_Structure1]]


=== Cartridge Directory Structure

The required directories of a cartridge must conform to a set structure or the cartridge can fail to function properly. You can add additional directories and files as needed to support the function of your cartridge. 

.Cartridge Directory Structure
====

<1> +Required+ files must exist for minimal OpenShift  support of the cartridge. 
<2> +Discretionary+ files are recommended, but not necessary. For example, +conf.d+  is the standard file where a web framework installs its +httpd+ configuration. 
<3> +Optional+ files are not necessary. Use optional files to support additional cartridge functionality.

----

$cartridge_name
 +- bin                        (required)	<1>
 |  +- setup                   (optional)	<2>
 |  +- install                 (optional)
 |  +- post-install            (optional)
 |  +- teardown                (optional)
 |  +- control                 (required)
 |- hooks                      (optional)
 |  +- set-db-connection-info  (discretionary)	<3>
 +- versions                   (discretionary)
 |  +- $software_version
 |  |  +- bin
 |  |     +- ...
 |  |  +- data
 |  |     +- template          (optional)
 |  |        +- .openshift
 |  |        |   +- ...
 |  |        +- ... (directory/file tree)
 |  |     +- template.git       (discretionary)
 |  |        +- ... (git bare repo)
 |  +- ...
 +- env                        (required)
 |  +- *.erb
 +- template                   (optional)
 |  +- ... (directory/file tree)
 +  template.git               (discretionary)
 +  +- ... (bare git repository)
 +- usr                        (optional)
 |  +- ...
 +- metadata                   (required)
 |  +- manifest.yml            (required)
 |  +- managed_files.yml       (optional)
 +- conf.d                     (discretionary)
 |  +- openshift.conf.erb
 +- conf                       (discretionary)
 |  +- magic

----

====

To support multiple software versions within one cartridge, create symbolic links between the `$cartridge_name/bin/control` file and the `$cartridge_name/versions/$software_version/bin/control` file. Alternatively, use the `$cartridge_name/bin/control` file as a shim to call the +control+ file for the desired version. 

When creating an instance of your cartridge for use by a gear, OpenShift  copies the files, links, and directories from the cartridge library, with the exception of the `$cartridge_name/usr/` directory. The `$cartridge_name/usr/` directory is symbolically linked to the gear's cartridge instance. This link enables all cartridge instances to share libraries and other data. 

See <<chap-Locking_Cartridges>> for details on customizing a cartridge instance. 


[[sect-Cartridge_Metadata_Elements]]

=== Cartridge Metadata Elements

OpenShift  uses a `manifest.yml` file located in the `$cartridge_name/metadata/` directory to determine the features a cartridge requires. OpenShift  also uses data from the `manifest.yml` file to provide information about the cartridge to users. 

.manifest.yml File

====

----

Name: PHP
Cartridge-Short-Name: PHP
Cartridge-Version: '1.0.1'
Compatible-Versions: ['1.0.1']
Cartridge-Vendor: redhat
Display-Name: PHP 5.3
Description: "PHP is a general-purpose server-side scripting language..."
Version: '5.3'
Versions: ['5.3']
License: "The PHP License, version 3.0"
License-Url: http://www.php.net/license/3_0.txt
Vendor: PHP Group
Categories:
  - service
  - php
  - web_framework
Website: http://www.php.net
Help-Topics:
  "Developer Center": https://openshift.redhat.com/community/developers
Cart-Data:
  - Key: OPENSHIFT_...
    Type: environment
    Description: "How environment variable should be used"
Provides:
  - php-5.3
  - "php"
  - "php(version) = 5.3.2"
Publishes:
  get-php-ini:
    Type: "FILESYSTEM:php-ini"
  publish-http-url:
    Type: "NET_TCP:httpd-proxy-info"
  publish-gear-endpoint:
    Type: "NET_TCP:gear-endpoint-info"
Subscribes:
  set-db-connection-info:
    Type: "NET_TCP:db:connection-info"
    Required: false
  set-nosql-db-connection-info:
    Type: "NET_TCP:nosqldb:connection-info"
    Required: false
  set-mysql-connection-info:
    Type: "NET_TCP:db:mysql"
    Required : false
  set-postgres-connection-info:
    Type: "NET_TCP:db:postgres"
    Required : false
  set-doc-url:
    Type: "STRING:urlpath"
    Required : false
Scaling:
  Min: 1
  Max: -1
Group-Overrides:
  - components:
    - php-5.3
    - web_proxy
Endpoints:
  - Private-IP-Name:   IP1
    Private-Port-Name: HTTP_PORT
    Private-Port:      8080
    Public-Port-Name:  PROXY_HTTP_PORT
    Mappings:
      - Frontend:      "/front"
        Backend:       "/back"
Additional-Control-Actions:
  - threaddump

----

====


[[Cartridge-Short-Name_Element1]]

=== Cartridge-Short-Name

OpenShift  creates several environment variables when installing a cartridge. The +Cartridge-Short-Name+ element forms part of these environment variable names. 

.Cartridge-Short-Name Entry for a PHP cartridge

====

----

Cartridge-Short-Name: PHP
		
Environment variables use PHP in their name:
		
OPENSHIFT_PHP_DIR
OPENSHIFT_PHP_IP
OPENSHIFT_PHP_PORT
OPENSHIFT_PHP_PROXY_PORT

----

====


[[Cartridge-Version_Element1]]

=== Cartridge-Version

The +Cartridge-Version+ element identifies the release version of a cartridge. The value uses the format: 

----

<number>[.<number>[.<number>[...]]]

For example:

Cartridge-Version: '1.0.3'

----

When you publish a new version of a cartridge, OpenShift  uses the +Cartridge-Version+ value to determine upgrade requirements for applications that use the cartridge. YAML treats +number.number+ as a float but OpenShift  requires a string for this value, so the value must be enclosed in single quotes ('). 

[[Compatible-Versions_Element1]]


=== Compatible-Versions

The +Compatible-Versions+ element is a list of previous cartridge versions that are compatible with the current cartridge version. 

.Compatible-Versions Entry

====

----

Compatible-Versions: ['1.0.1']

----

====

To be compatible with a previous version, the code changes in the current cartridge version must not require a restart of the cartridge or of an application using the cartridge. 

If the previous cartridge version is not in the +Compatible-Versions+ list when you update the cartridge to a new version, OpenShift  stops the cartridge, installs the new code, runs +setup+, and restarts the cartridge. This process results in a short amount of downtime for applications that use the cartridge. 


[[Cartridge-Vendor1]]

=== Cartridge-Vendor

The +Cartridge-Vendor+ element identifies the creator of a cartridge. OpenShift  uses this value to differentiate between similar cartridges installed on the system. You can use a company name or an individual identifier for this value. 

.Cartridge-Vendor Entry

====

----
Cartridge-Vendor: redhat
----

====


[[Version_Element1]]

=== Version

The +Version+ element is the default version of the software packaged in the cartridge. 

.Version Entry

====

----

Version: '5.3'

----

====


[[Versions_Element1]]

=== Versions

The +Versions+ element is the list of software versions packaged in the cartridge. 

.Versions Entry
====

----

Versions: ['5.3']

----

====


[[Source-Url_Element1]]

=== Source-Url

The +Source-Url+ element is the location from which OpenShift  downloads cartridge files during application creation. 

.Supported Source Schemes
[options="header"]
|===============

|Scheme |Method |Expected Inputs
					
|
						git
					|
						clone
					|
						git repo
					
|
						https
					|
						GET
					|
						zip, tar, tag.gz, tgz
					
|
						http
					|
						GET
					|
						zip, tar, tag.gz, tgz
					
|
						file
					|
						file copy
					|
						cartridge directory tree
					

|===============

.Source-Url Entry
====

----

Source-Url: https://github.com/example/killer-cartridge.git
Source-Url: git://github.com/chrisk/fakeweb.git
Source-Url: https:://www.example.com/killer-cartridge.zip
Source-Url: https://github.com/example/killer-cartridge/archive/master.zip

----

====


[[Source-Md5_Element1]]

=== Source-Md5

The +Source-Md5+ element is an MD5 digest. If OpenShift  downloads a cartridge using a non-Git scheme, it verifies the downloaded file against this MD5 digest. 

.Source-Md5 Entry

====

----

Source-Md5: 835ed97b00a61f0dae2e2b7a75c672db

----

====


[[Additional-Control-Actions_Element1]]

=== Additional-Control-Actions

The +Additional-Control-Actions+ element is a list of optional actions a cartridge supports. OpenShift  can only call optional actions if they are included in this element. 

.Additional-Control-Actions Entry
====

----

Additional-Control-Actions:
  - threaddump

----


====


[[Endpoints_Element1]]

=== Endpoints

See <<chap-Exposing_Services>>. 

[[Sample_conf.dopenshift.conf.erb1]]

=== Example openshift.conf.erb File

+httpd+ is a common base for OpenShift  cartridges. You can use this example `conf.d/openshift.conf.erb` file as a starting point for writing a cartridge based on +httpd+. 

----
ServerRoot "<%= ENV['OPENSHIFT_HOMEDIR'] + "/ruby-1.8" %>"
DocumentRoot "<%= ENV['OPENSHIFT_REPO_DIR'] + "/public" %>"
Listen <%= ENV['OPENSHIFT_RUBY_IP'] + ':' + ENV['OPENSHIFT_RUBY_PORT'] %>
User <%= ENV['OPENSHIFT_GEAR_UUID'] %>
Group <%= ENV['OPENSHIFT_GEAR_UUID'] %>

ErrorLog "|/usr/sbin/rotatelogs <%= ENV['OPENSHIFT_HOMEDIR']%>/ruby-1.8/logs/error_log-%Y%m%d-%H%M%S-%Z 86400"
CustomLog "|/usr/sbin/rotatelogs <%= ENV['OPENSHIFT_HOMEDIR']%>/logs/access_log-%Y%m%d-%H%M%S-%Z 86400" combined

PassengerUser <%= ENV['OPENSHIFT_GEAR_UUID'] %>
PassengerPreStart http://<%= ENV['OPENSHIFT_RUBY_IP'] + ':' + ENV['OPENSHIFT_RUBY_PORT'] %>/
PassengerSpawnIPAddress <%= ENV['OPENSHIFT_RUBY_IP'] %>
PassengerUseGlobalQueue off
<Directory <%= ENV['OPENSHIFT_REPO_DIR]%>/public>
  AllowOverride all
  Options -MultiViews
</Directory>

----




















 





 














