require 'asciidoctor'
require 'csv'
require 'pandoc-ruby'
require 'pathname'
require 'rake'

task :build do
  Dir.glob("*.adoc").each do |file|
    puts "Processing #{file}"
    Asciidoctor.render_file file, :in_place => true, :safe => :safe, :template_dir => './templates', :attributes => %w(source-highlighter=coderay coderay-css=style stylesdir=./stylesheets imagesdir=./images stylesheet=origin.css linkcss! icons=font idprefix= idseparator=- sectanchors)
  end
end

task :build_hangouts do
  hangouts = [
    "= OpenShift Origin Hangouts",
    "OpenShift Origin Documentation Project <dev@lists.openshift.redhat.com>",
    ":data-uri:",
    ":toc2:",
    ":icons:",
    "",
  ]
  File.open('_origin_hangouts_header.adoc').each_line do |line|
    hangouts << line.chomp
  end
  hangouts << ''
  fh = File.open('origin_hangouts.csv', 'r')
  csv = CSV.new(fh, { :col_sep => '|'})
  idx = 0
  csv.each do |row|
    next if row[0].start_with?('#')
    title = row[0].strip
    description = row[1].strip
    # Assumes a URL format like
    # http://www.youtube.com/watch?v=tMphZs8P2xU
    # or
    # http://www.youtube.com/embed/E7veBgx3PP8
    url = row[2].strip
    video_id = url.split('=')[-1]
    if url.match(/embed/)
      video_id = url.split('/')[-1]
    end
    date = row[3]
    hangouts << "=== #{title}"
    if not date.nil?
      hangouts << "_Aired: #{date.strip}_ +"
    end
    hangouts.concat([description, "", '++++', "<iframe id='ytplayer' type='text/html' width='640' height='390' src='http://www.youtube.com/embed/#{video_id}?autoplay=0&origin=http://openshift.github.io' frameborder='0' allowfullscreen></iframe>", '++++', ""])
    idx = idx + 1
  end
  fh.close

  File.open('_origin_hangouts_footer.adoc').each_line do |line|
    hangouts << line.chomp
  end

  # AsciiDoc => HTML
  output_html = Asciidoctor.render hangouts.join("\n"), :header_footer => true, :safe => :safe, :template_dir => './templates', :attributes => %w(source-highlighter=coderay coderay-css=style stylesdir=./stylesheets imagesdir=./images stylesheet=origin.css linkcss! icons=font idprefix= idseparator=- sectanchors)

  # Out to disk
  File.open('origin_hangouts.html', 'w') {|f| f.write(output_html)}
end

task :build_peps do
  PandocRuby.allow_file_paths = true

  pep_files = []

  File.symlink("../../openshift-pep","openshift-pep")

  Dir.glob("openshift-pep/openshift-pep-*.md").each do |file|
    # Markdown => AsciiDoc
    asciidoc_txt = PandocRuby.markdown(file, 'no-wrap').to_asciidoc

    # Fix image links to exclude paths; this enables AsciiDoctor to correctl locate the source image
    asciidoc_txt.gsub!(/image:images\//,'image:')

    # Target filename
    file_base = File.basename(Pathname.new(file).basename, '.*')
    output_file = "#{file_base}.html"

    # PEP info; this will break if the template / naming convention changes too much
    pep_number = file_base.split("-")[2]
    pep_title = asciidoc_txt.match(/Title\:\ (.*)\ \+\n/)[1]
    pep_files << "#{pep_number}: link:#{output_file}[#{pep_title}]"

    # Prepend AsciiDoc header info
    input_text = [
      "= OpenShift PEP #{pep_number}: #{pep_title}",
      "OpenShift Origin Documentation Project <dev@lists.openshift.redhat.com>",
      ":data-uri:",
      ":toc2:",
      ":icons:",
      "",
      asciidoc_txt,
    ].join("\n")

    # AsciiDoc => HTML
    output_html = Asciidoctor.render input_text, :header_footer => true, :safe => :safe, :template_dir => './templates', :attributes => %w(source-highlighter=coderay coderay-css=style stylesdir=./stylesheets imagesdir=openshift-pep/images stylesheet=origin.css linkcss! icons=font idprefix= idseparator=- sectanchors)

    # Write it to disk
    File.open(output_file, 'w') {|f| f.write(output_html)}
  end

  File.unlink('openshift-pep')

  # Write the index to be included in the Documentation Home page
  peps_list = pep_files.join(" +\n")
  peps_text = [
    '[cols="1",options="header"]',
    "|===",
    "|OpenShift PEPs",
    "",
    "a|#{peps_list}",
    "",
    "|===",
  ].join("\n")

  # Write it to disk
  File.open('_pep_list.adoc', 'w') {|f| f.write(peps_text)}
end

task :build_rest do
  # Create the rest_api directory
  unless Dir.exists?('rest_api')
    Dir.mkdir('rest_api')
  end
  Dir.glob("../broker/doc/html/16/*.html").each do |file|
    FileUtils.copy(file, 'rest_api/' + File.basename(file))
  end
end

task :build_all do
  Rake::Task['build_hangouts'].execute
  Rake::Task['build_peps'].execute
  Rake::Task['build_rest'].execute

  # The regular files are built last; this ensures that
  # the include files generated by the other builds are
  # included in the index
  Rake::Task['build'].execute
end

task :package do
  builds = [
    { :branch => 'master',
      :site_dir => 'documentation-latest',
      :include_hangouts => false,
      :docs_version => 'Version Latest'
    },
    { :branch => 'master',
      :site_dir => 'documentation',
      :include_hangouts => true,
      :doc_version => 'Version 4.0'
    },
  ]

  branches = `git branch`.split(/\n/).map{ |branch| branch.strip }

  # Remeber the working branch so that we can return here later.
  working_branch = 'master'
  branches.each do |branch|
    next if not branch.start_with?('*')
    working_branch = branch.sub!(/^\* /,'')
  end

  # Make sure the working branch doesn't have any uncommitted changes
  changed_files = `git status --porcelain`
  if not changed_files.empty?
    puts "Warning: Your current branch has uncommitted changes. Hit <CTRL+C> if you want to exit."
    print "Starting packager in "
    [3,2,1].each do |i|
      print "#{i}..."
      sleep 1
    end
    print "\n"
  end

  # Now make sure the build branches are available.
  missing_branches = false
  builds.each do |build|
    if not branches.include?(build[:branch])
      if not missing_branches
        puts "ERROR: One or more branches for packaging are not available in this local repo:"
        missing_branches = true
      end
      puts "- #{build[:branch]}"
    end
  end
  if missing_branches
    puts "Add these branches and rerun the packaging command."
    exit 1
  end

  # Start packaging. Clear out the old package dir before making the new package
  if Dir.entries('.').include?('package')
    system 'rm', '-rf', 'package'
  end
  Dir.mkdir('package')

  # Now make each package.
  builds.each do |build|
    # Check out this build branch
    system("git checkout #{build[:branch]}")

    if not $?.exitstatus == 0
      puts "ERROR: Could not check out branch #{build[:branch]}, please investigate."
      exit 1
    end

    # Make the build dir
    build_dir = "./package/#{build[:site_dir]}"
    Dir.mkdir(build_dir)

    # Build the docs
    if build[:include_hangouts]
      Rake::Task['build_hangouts'].execute
    end
    Rake::Task['build_peps'].execute
    Rake::Task['build_rest'].execute
    # The regular files are built last.
    Rake::Task['build'].execute

    # Move to the package area
    ['archive','files','fonts','images','stylesheets','templates','rest_api'].each do |dir|
      system("cp -r ./#{dir} #{build_dir}")
    end
    system("rm _*.html")
    system("cp *.html #{build_dir}")

    # Clean everything up
    Rake::Task['clean'].execute
  end

  # Return to the original branch
  system("git checkout #{working_branch}")

  puts "Packaging completed."
end

task :clean do
  sh "rm -rf _pep_list.adoc rest_api *.html" do |ok,res|
    if ! ok
      puts "Nothing to clean."
    end
  end
end

task :clean_all do
  Rake::Task['clean'].execute
  sh "rm -rf package" do |ok,res|
    if ! ok
      puts "Good to go."
    end
  end
end
